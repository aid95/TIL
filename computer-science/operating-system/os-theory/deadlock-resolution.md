# 교착상태

프로세서는 필요한 자원을 얻기 위해 Blocked 상태로 전이될 수 있다고 알고 있다. 하지만 필요한 자원이 영원히 얻을 수 없는 상태가 된다면 이를 `Deadlock 상태`라고 하며, 이런 Deadlock된 프로세스가 있는 시스템내에 존재한다면 `시스템이 deadlock 상태`에 있다라고 말하게 된다.

## Deadlock vs. Starvation

![Deadlock vs. Starvation](https://i.imgur.com/2i2Wioj.png)

`일을 할 수 없는 상태`를 두고 본다면, Starvation(이하 기아 현상)과 Deadlock(이하 교착 상태) 상태는 비슷하다고 생각될 수 있다. 하지만 기아 현상의 경우는 *운이 없어서* 내 차례가 계속 밀리게 되는 현상이고, Deadlock의 경우 **가능성이 0%인 상황**이다. 또 기아 현상은 *Ready queue*에서 발생하는 반면, Deadlock은 *Wait queue*(사진에서의 asleep)에서 발생하게 된다. 추가적으로 어떤 자원을 기다리는지도 다르다.

## 자원의 분류

교착 상태를 설명하면 `자원`이라는 단어가 자주 언급된다. 이 장에서 언급되는 자원은 Hardware vs. Software 자원으로 구분되며 다음과 같은 분류법에 따라 분류될 수 있다.

- 선점 가능 여부에 따른 분류
  - 선점 가능한 자원
    - 선점 당한 후, 돌아와도 문제가 발생하지 않는 자원
      - Processor (Context switching)
      - Memory (Swap device)
  - 비선점 자원
    - 선점 당하면, 이후 진행에 문제가 발생하는 자원 (rollback, restart등의 작업이 필요함)
      - disk drive
- 할당 단위에 따른 분류
  - 전체 할당 자원
    - 자원 전체를 프로세스에 할당
      - Processor, disk drive 등
  - 분할 할당 자원
    - 하나의 자원을 여러 조각으로 나누어, 여러 프로세스들에게 할당
      - Memory 등
- 동시 사용 가능 여부에 따른 분류
  - Exclusive allocation resource
    - 한 순간에 한 프로세스만 사용 가능한 자원
      - Processor, memory, disk drive 등
        - Memory는 여러 구역으로 나뉘어 할당될 수 있지만 *할당 받은 영역은 해당 프로세스만 사용이 가능하다.*
  - Shared allocation resource
    - 여러 프로세스가 동시에 사용 가능한 자원
      - Program(S/W), Shared data 등
- 재사용 가능 여부에 따른 분류
  - 지속적 재활용 가능한 자원
    - 시스템 내에 항상 존재하는 자원, 사용이 끝나면 다른 프로세스가 사용 가능
      - Processor, memory, disk drive, program 등
  - 소비성 자원
    - 한 프로세스가 사용한 후에 사라지는 자원
      - Signal, message 등

## 교착 상태(Deadlock)과 자원의 종류

그렇다면 교착 상태를 발생 시키는 자원은 어떤게 있을까?

- Non-preemptible resources
- Exclusive allocation resources
- Serially reusable resources

> 여기서 CR(소비성 자원) 또한 교착 상태를 유발할 수 있지만, 강의에서 이 내용까지 고려하게 되면 Deadlock model이 너무 복잡해져 제외한다고 설명한다.

교착 상태는 기본적으로 Non-preemptible한 자원에서 발생하게 된다. 한번 할당 받으면 끝날때까지 사용하며 이 자원이 필요한 프로세스는 영원히 기다려야 하기 때문이다. 같은 맥락으로 Exclusive allocation resources 또한 내 영역은 나 이외는 사용할 수 없으며, Serially reusable resources도 같은 내용이다. <u>요약하자면 먼저 선점된 프로세스 외엔 사용이 불가능한 자원은 교착 상태를 유발할 수 있다.</u>

## 교착 상태 발생 필요 조건

Non-preemptible한 자원이 교착 상태를 발생하는이긴 하지만 요청과 반환을 적절히 이뤄진다면 Non-preemptible한 자원을 사용하더라도 교착 상태는 발생하지 않는다. 이런 자원의 특성과 함께 프로세스의 특성이 겹쳐지면 교착 상태가 발생하게 된다.

- Exclusive use of resources - 자원의 특성
- Non-preemptible resources - 자원의 특성
- Hold and wait (Partial allocation) - 프로세스의 특성
  - 자원을 하나 Hold하고 다른 자원 요청
- Circular wait - 프로세스의 특성

위 네 가지 조건이 만족하게 되면 교착 상태가 발생하며 이중 <u>하나만 깨져도 교착 상태 문제는 해결</u>된다.

## 교착 상태 예방

앞서 교착 상태는 필요 조건 네 가지 중 하나만 해결되어도 발생하지 않는다고 설명했다. 그렇다면 각 조건은 어떤 방법으로 해결할 수 있을까.

### 모든 자원을 공유 허용

**Exclusive use of resources 조건**을 제거하기 위해선 모든 자원을 독점할 수 없는 공유 자원으로 만드는 방법이다. 하지만 이 방법은 현실성이 없으므로 넘어가자.

### 모든 자원에 대해 선점 허용

**Non-preemptible resources 조건 제거**하기. 이 방법 또한 현실적으로 불가능하다. 유사한 방법으로 프로세스가 할당 받을 수 없는 자원을 요청한 경우 기존 작업을 취소하고 작원을 모두 반납한다. 이 작업을 성공할때 까지 계속 다시 시작한다. 매우 <u>*비효율적*</u>이며 <u>*자원 낭비가 심각*</u>할 것이다.

### 필요 자원 한번에 모두 할당 (Total allocation)

**Hold and wait 조건 제거**. 작업에 필요한 모든 자원을 받기 전까진 작업을 수행하지 않고 모든 자원을 할당 받으면 작업을 수행하는 방법이다. 언뜻 괜찮아 보이지만 이 방법은 <u>*자원 낭비가 발생*</u>하게 된다. 프로세스는 모든 자원을 항상 필요하지 않다. 어떤 자원은 매우 짧은 순간만 필요하지만 이 자원이 다른 프로세스에겐 매우 절실할 수 있으며 이를 위해 <u>*무한정 대기*</u>할 수 밖에 없게 된다. 따라서 자원을 효율적으로 사용할 수 없게 된다.

### Circular wait 조건 제거

Totally allocation을 일반화한 방법으로, 자원에게 **순서**를 부여한다. 프로세스는 순서의 증가 방향으로만 자원 요청이 가능하기 때문에 Circular wait가 절대로 발생할 수 없지만, 많이 사용되는 자원에서 <u>*병목 현상*</u>이 발생할 수 있다. 따라서 단 하나의 자원만이 공통적으로 필요하고 그 다음(또는 자원이 둘 중 하나만 있어도 수행이 가능한 경우) 순서는 모두 각각의 자원이 필요한 프로세스들이라도 하나의 공통 자원에서 대기하기 때문에 <u>*자원이 낭비*</u>가 된다.

이 처럼 교착 상태 예방은 *"조건 하나를 제거하면 교착 상태는 절대 발생하지 않는다."* 라는 간단한 전제를 가지지만, 이를 위한 방법이 *비현실적*이고, *자원 낭비*가 너무 심하기 때문에 예방이 아닌 **회피**에 집중하게 된다.
