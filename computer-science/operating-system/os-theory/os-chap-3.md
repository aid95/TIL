# 프로세스의 이해

## 프로세스의 이해

프로세스는 실행중인 프로그램으로 커널에 등록되어 커널의 관리하에 있는 작업을 뜻한다. 프로세서는 능동적인 개체로 운영체제에게 필요한 자원을 요청하며 운영체제는 프로세스가 필요한 자원을 할당해 프로세스가 작원을 할 수 있도록 지원한다. 프로세스는 PCB라는 관리 블록에 자신의 상태를 저장하고 PCB를 통해 운영체제는 프로세스를 관리할 수 있다.

* CPU time
* Memory
* Files
* I/O devices

위 항목은 모두 운영체제가 관리하는 요소들이며 운영체제는 프로세스의 관리가 핵심 기능이라 할 수 있다. 이런 프로세스는 여러개의 섹션으로 나뉜 메모리 레이아웃을 가지고 있는데 다음과 같은 섹션으로 나뉜다.

* Text section
  * 명령어 코드들이 위치한 섹션
* Data section
  * 전역 변수들이 위치한 섹션
* Heap section
  * 프로그램이 실행중 동적으로 할당된 메모리가 위치한 섹션
* Stack section
  * 프로그램의 함수가 수행하면서 필요한 일시적인 데이터 저장소
  * 함수의 매개변수, 리턴 주소, 지역 변수등이 위치할 섹션

### 프로세스의 라이프 사이클

**Active state**

프로세스는 다음과 같이 5개의 상태를 가지고 있다.

![&#xADF8;&#xB9BC;1. &#xD504;&#xB85C;&#xC138;&#xC2A4;&#xC758; &#xB77C;&#xC774;&#xD504; &#xC0AC;&#xC774;&#xD074;](https://i.imgur.com/Ybo62aN.png)

* New
  * 프로그램을 커널에 등록
    * PCB 할당 및 프로세스 생성
    * 필요한 메모리가 충분하다면 Ready로 이동
      * 필요한 메모리가 충분하지 않다면 suspend ready로 이동
* Running
  * Ready 상태에서 Dispatch에 의해 프로세서가 할당된 상태
  * 두 곳으로 상태 전의가 가능
    * Preemption \(Running to **Ready state**\)
      * 스케줄링
    * Block/Sleep \(Running to **Asleep state**\)
      * I/O 등 자원 할당 요청
* Wating
  * I/O 인터럽트 또는 이벤트 발생시 대기
  * 작업 후 Ready 상태로 이동
    * 현재 Running 상태 작업이 있을 수 있으니 새로 줄을 서서 자신이 작업이 될 수 있도록 준비
* Ready
  * 프로세서 외에 다른 모든 자원을 할당 받은 상태
    * 즉시 실행 가능 상태
* Terminated
  * 모든 실행이 완료되어 종료된 상태

**Suspended State**

![Suspended State](https://i.imgur.com/Ahy8x4Q.png)

메모리를 할당받지 못한\(빼앗긴\) 상태로, 기존의 메모리는 프로그램 정보를 저장하기 위한 특별한 파일 시스템인 swap device에 보관된다. 이 작은 커널 또는 사용자에 의해 발생하여 Swap-out\(suspended, 메모리를 뺏김\), Swap-in\(resume, 스왑된 메모리 복구\) 두 가지 이벤트로 상태가 전의된다.

**PCB\(Process Control Block\) or TCB\(Task control Block\)**

PCB는 커널 공간에 존재하며 운영체제가 프로세스들을 관리하기 위한 정보를 가지고 있다. 그 중 대표적인 정보는 다음과 같다.

* 프로세스 ID \(PID, Process Identification Number\)
* 프로세스의 상태
* 프로그램 카운터 \(다음 명령어 위치를 가리키는 포인터\)
* CPU registers
* CPU-scheduling information
* Memory-management information
* Accounting information
* I/O status information
* etc...

따라서 위 정보를 알고 있다면 해당 프로세스의 다음 수행할 명령어와 그전의 상태를 가지고 다음 작업을 수행하며 여러개의 프로세스가 병렬적으로 수행되어도 각각의 프로세스는 마치 하나의 줄기가 뻗어나가는 것 처럼 작업을 이어서 수행할 수 있게 된다. 하지만 _프로세스가 유지해야할 모든 정보를 가지고 있기 때문에 굉장히 **무거운 구조체 데이터**_이다.

### Process concept

프로세스는 하나의 쓰레드만 수행하여 오직 하나의 쓰레드만 컨트롤 할 수 있었지만, 현재 대부분의 운영체제에서는 이 개념이 확장되어 하나의 프로세스에서 여러개의 쓰레드를 수행하여 병렬적인 처리가 가능하게 된다. 기존 멀티프로세스가 아닌 멀티쓰레드의 도입의 이유는 쓰레드는 프로세스보다 가볍게 구현하여 시스템 자원을 효율적으로 사용하고 CPU의 사용률을 극대화할 수 있다.

### Process scheduling

멀티프로그래밍의 목적은 동시에 여러개의 프로세스를 수행하여 CPU의 사용률를 극대화하기 위해서이다. 이걸 구현하기 위해서 시분할을 통해 엄청 빠른 프로세스간의 스위치를 통해 마치 사람의 눈으론 모든게 동시에 수행되고 있는 것 처럼 보이게 할 수 있다. 하지만 이런 시분할은 어떤 프로세스를 다음으로 수행할지가 중요한데 어떤 알고리즘에 의해 Sheduling queues의 ready queue 담아두고 뽑아서 수행하게 된다. 만약 wait인 경우는 wait queue에 담아두고 ready queue로 넘어간다. \(구글 Queueing diagram 참고\)

앞서 설명한 여러 프로세스가 병렬적으로 수행되기 위해선 각 프로세스는 자신의 지금까지 한 작업의 상태를 PCB에 기록하고 CPU는 다음에 해당 PCB를 읽으면 작업을 이어서 할 수 있게된다. 이런 CPU가 수행하던 PCB와 다음 수행할 PCB를 교환하는 작업을 _**`Context switch`**_라고 한다.

따라서 Context switching은 다음과 같은 작업을 수행한다.

* CPU core가 다른 프로세스로 스위치
* 현재 프로세스의 상태를 저장
* 스위칭할 프로세스의 상태를 불러옴

### 프로세스의 생성

프로세스는 `fork()` 로 생성할 수 있으며 자식 프로세스로 생성하게 된다.

* Execute concurrently
* Wait

이런 수행은 2가지의 상태가 존재하는데 하나는 동시에 수행되는 것과 자식 프로세스가 종료되기까지 기다리는 상태가 존재한다.

* Duplicate of the parent process
* New program loading

#### Zombie and Orphan

프로세스가 자식 프로세스를 생성하면 자식 프로세스는 작업을 마쳤지만 부모 프로세스에서 `wait()` 해주지 않으면 자식 프로세스는 Zombie 프로세스가 되며, 자식 프로세스가 실행 중이지만 부모 프로세스가 `wait()` 해주지 않고 혼자 종료되면 자식 프로세스는 Orphan 프로세스가 된다. 두 기준은 자식 프로세스의 종료 유/무에 따라서 부모 프로세스가 wait\(\) 해주지 않을 경우로 나뉜다.

#### 자식 프로세서의 생성, fork\(\)

운영체제는 프로그램이 메모리에 올라온 프로세스를 CPU의 정보와 프로세스의 정보 및 리소스를 PCB에 저장하고, 각각의 PCB를 Context switching을 하면 동시성을 제공한다.

fork\(\) 시스템 콜은 새로운 프로세스를 생성하며 생성된 프로세스는 부모 프로세스의 메모리 공간을 `복사`한다. 때문에 두 프로세스는 독립된 메모리를 가지기 때문에 전역 변수와 같은 데이터를 공유하지 않는다. 이후 fork\(\) 호출 이후의 명령행을 수행하며 두 프로세스의 차이는 fork\(\)의 반환값 PID가 0\(자식 프로세스\), 0 이외의 값\(부모 프로세스\)를 구분할 수 있다.

자식 프로세스의 생성한 부모 프로세스는 wati\(\)를 호출해 Ready queue에서 Wait queue로 이동해 자식 프로세스의 interrupt를 대기한다.

### IPC

두 프로세스가 개별적으로 동작하면 스케쥴링만 신경쓰면 아무런 문제가 발생하지 않지만\(independent한 상황\), 두 프로세스가 서로에게 영향을 주거나, 받는 상황에선\(공유하는 데이터가 있는 경우\) 어떻게 처리할지에 대한 방안

* 공유 메모리

두 프로세스가 공유하는 메모리 공간을 가지고 공유 데이터를 교환하는 방법

* 메시지 전송

메세지 큐를 통해서 서로에게 메세지를 교환하며 두 프로세스간의 협업

#### 생성-소비자 문제

**공유 메모리를 이용한 솔루션**

버퍼를 둠으로써 생성자는 버퍼에 데이터를 채우고, 소비자는 버퍼에 쌓인 데이터를 소비한다. 하지만 버퍼가 가득차면 생성자는 대기하고, 버파가 비워있으면 소비자는 대기하게 된다. 여기서 버퍼를 공유 메모리에 해당한다.

하지만 공유 메모리를 사용하게되면 공유 메모리 구현에 대한 책임을 애플리케이션 개발자에게 위임하기 때문에 개발자의 부담이 높아진다.

**POSIX shared memory**

POSIX shared memory는 메모리 영역에 파일을 맵핑하여 공유 메모리 영역을 만들게 된다.

**메세지 전송**

공유 메모리에서 발생하는 생성-소비에 대한 구현 책임을 O/S가 책임지고, 개발자는 서로의 메세지 링크에 집중할 수 있다. 때문에 구현이 단순해지게 된다.

**직접 전달**

각 프로세스가 커뮤니케이션할 상대 프로세스는 명시적으로 표현된 이름을 통해서 직접 전달. 때문에 누가, 누구에게 전달하기를 명시적으로 표현하는게 중요한다.

명시적인 두 프로세스의 사이에는 자동적으로 링크가 생성되고, 두 프로세스 간의 링크는 하나만 존재하게 된다.

**간접 전달**

메세지는 메일박스 또는 포트로부터 송수신이 이뤄진다. 따라서 두 프로세스 사이에서 공유하는 메일박스\(또는 포트\)가 존재할때 링크가 생성된다. 따라서 송신자와 수신자는 특정된 프로세스가 아니라도 서로간의 커뮤니티가 가능하다. 따라서 서로 다른 링크가 무수히 존재할 수 있다. 운영체제는 새로운 메일박스 생성을 제공하고, 메세지는 메일박스를 통해 송수신, 그리고 메일박스를 삭제하는 기능만 제공한다.

**Pipe**

메세지 전송에 있어 두 프로세스간 메세지 교환은 파이프를 통해서 이뤄진다. 이 파이프를 구현에는 4가지 고려사항이 있는데 다음과 같다.

* 커뮤니케이션은 단방향 전송이냐, 양방향 전송이냐?
* Half-duplex이냐 Full-duplex이냐?
* 두 프로세스간의 관계가 있어야 하는가?
  * 파이프의 경우 구현의 간편함을 위해 부모-자식 관계가 필요하다
* 네트워크 환경에서 동작하는가?

파이프에는 두 가지의 파이프가 존재한다.

* Ordinary pipes
  * 두 프로세스간 관계성을 가진 상황에서 사용하는 파이프
  * 두개의 파이프를 사용해 Full-duplex가 가능하다.
* Named pipes

**Blocking OR Non-blocking : Synchronous OR Asynchronous**

현재 작업이 모두 끝나고 다음 작업을 수행하는 방식이 `Blocking`, 작업을 요청하고 해당 요청의 완료와 상관없이 다음 작업을 수행하는 것이 `Non-blocking`

#### Server-Client

앞서 살펴본 두 프로세스간의 통신은 하나의 PC안에서만 통신한다는 제한이 있다. 하지만 현재의 대부분의 컴퓨터는 인터넷을 통해 서로 떨어진 컴퓨터간의 존재하는 프로세스간의 통신을 위한 메커니즘이 필요하다.

**소켓**

두 원격지에 연결을 IP를 이용해 정의된 파이프로 서로간의 커뮤니티를 사용한다. 하지만 두 목적지의 환경\(운영체제, 하드웨어 스펙 등등\)이 다를 경우 서로간의 커뮤니티케이션이 어려워진다.

**RPC**

RPC system에서는 클라이언트측에선 서버의 세부사항이 숨겨진 원격지 함수를 호출하기 위해 Stub가 제공되어야 한다. 클라이언측에서 원격지로 넘겨주고 받는 데이터를 marshals를 통해 넘겨준다.

