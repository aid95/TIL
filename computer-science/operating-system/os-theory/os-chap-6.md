# 프로세스

> 이 글은 유튜브 [HPC Lab. KOREATECH](https://www.youtube.com/channel/UCHvXywxOtwLedY5OX-Teg5w) 채널의 운영체제 강의를 수강하며 정리한 글입니다. 글에 포함된 내용 및 사진의 저작권은 [HPC Lab. KOREATECH](https://www.youtube.com/channel/UCHvXywxOtwLedY5OX-Teg5w) 채널에게 있으며 요청에 의해 언제든지 내려갈 수 있습니다.

다중 프로그래밍 시스템에서는 여러 개의 프로세스들이 존재하며 각 프로세스들은 서로 독립적으로 동작한다. 하지만 독립된 프로세스들이 *동일한 데이터를 동시에 참조*(쓰기 작업이 있을 시)하고 있다면 문제가 발생할 수 있다. 이런 문제를 해결하기 위해서는 동일한 데이터를 동시에 참고하고 있는 프로세스들간의 **대화**가 있어야 하며 이 과정을 **프로세스 동기화**라고 한다.

이 장을 학습하기 전 주요 단어에 대해 알고가자.

* 공유 데이터(Shared data) : 여러 프로세스들이 공유하는 데이터
* 임계 영역(Critical section) : 공유 데이터를 접근하는 코드 영역(code segment)
* 상호배재(Mutual exclusion) : 둘 이상의 프로세스가 동시에 *critical section에 진입*하는 것을 막는 것

## 임계 영역

![Critical section example](https://i.imgur.com/JVad7md.png)

임계 영역은 여러 프로세스가 공유 데이터를 접근하는 영역을 뜻한다. 위 그림처럼 두 프로세스가 공유하는 sdata에 각각 1씩 더한다면 메모리에는 최종적으로 2가 저장될거라 생각할 수 있다. 하지만 우리 프로그램을 개발하고 최종적으로 얻는  기계어 명령은 *원자성(Atomicity)*와 *Indivisible(분리불가능)*이란 특성으로 <u>한 기계어가 실행 도중엔 인터럽트를 받지 않는 특징</u>을 가진다. 따라서 두 프로세스에서 동시에 작업이 이뤄진 경우 각 명령어가 수행되며 sdata에 데이터를 읽어오는 명령행을 수행하는 시점에 따라서 메모리에 저장되는 결과는 달라질 수 있다.

## 상호배재

임계 영역에서 두 프로세스가 동시에 공유 메모리를 사용하면 생길 수 있는 문제를 알아봤다. 임계 영역에서 발생하는 문제의 핵심은 두 프로세스가 ***동시에*** 같은 메모리를 사용하기 때문이다. 따라 임계 영역의 진입을 제어한다면 병렬성을 유지하면서 안전한 프로그램을 작성할 수 있을것이다.

상호배재를 구현하기 위해선 다음과 같은 기본 연산과 요구 조건이 필요하다.

* enterCS primitive
  * 임계 영역 진입 전 검사
  * 다른 프로세스가 임계 영역 안에 있는지 검사
* exitCS primitive
  * 임계 영역을 벗어날 때의 후처리 과정
  * 임계 영역을 벗어남을 시스템이 알림

다음은 상호배재가 지켜야할 요구조건이다.

* 상호배재(Mutual exclusion)
  * 임계영역에 프로세스가 있으면, *다른 프로세스의 진입을 금지*.
* 진행(Progress)
  * 임계영역에 있는 프로세스 외에는, *다른 프로세스가 임계영역에 진입하는 것을 방해하면 안됨*
* 한정대기(Bounded waiting)
  * 프로세스의 임계영역 *진입은 유한시간 내에 허용*되어야 함

멀티 프로그래밍에선 실행 동작이 예측하기 어렵고, 디버깅과 재연이 어려워 배우는 단계에서 상호배재 알고리즘을 당장 만드는 것은 굉장히 어렵고 많은 경험이 필요하다. 따라서 선구자들이 경험과 기술을 담아 만든 알고리즘을 알아보자.

### Dekker's Algorithm

Dekker's algorithm은 Two process ME을 보장하는 최초의 알고리즘이다.

![Dekker's algorithm](https://i.imgur.com/d2iTZbl.png)

2개의 프로세스의 상호배재를 해결하기 위해 Dekkers' algorithm에선 flag, turn이라는 2개의 상태 변수를 사용한다. flag은 경우 프로세스가 임계 영역에 진입함을 의미하며, turn은 차례를 의미한다.

두 프로세스는 1행에서 임계 영역의 진입하기 전 flag에 자신이 진입함을 알리고 만약 상대방 프로세스가 임계영역을 사용하고 있다면 while을 수행하며 대기한다. 만약 두 프로세스가 동시에 임계영역에 진입하려고 시도한다면 두 프로세스 중 어떤 프로세스가 우선시 해야할지 정해야 한다. 이 문제를 해결하기 위해서 turn 변수를 사용한다. 만약 두 프로세스가 대기중이면 자기 차례(turn)이 아니면 내 flag를 내려 상대방이 임계영역에 진입할 수 있도록 한다. 상대방은 임계영역의 작업을 모두 수행한 후 내 flag를 내리고 상대방에게 차례(turn)을 넘긴다.

## N-Process 상호배재

이제 N개의 프로세스의 상호배재에 대해 알아보자, N개의 상호배재 알고리즘은 다익스트라, 크누스, 램포트, 핸슨등이 있는데 이 강의에선 다익스트라만 소개한다.

다익스트라 알고리즘도 앞의 Dekker's algorithm과 같이 flag, turn 상태 변수를 사용한다. 하지만 상태에 대해 더 작은 단위로 잘라 문제를 해결하는 상태는 다음과 같이 구분한다.

- IDLE : 프로세스가 임계 지역 진입을 시도하고 있지 않을 때
- WANT-IN : 프로세스의 임계 지역 진입 시도 1단계일 때
- IN-CS : 프로세스의 임계 지역 진입 시도 2단계 및 임계 지역 내에 있을 때

![Dijkstra's Algorithm](https://i.imgur.com/opsZEL6.png)

다익스트라 알고리즘에선 임계 영역 진입하기 전 2단계를 거친다. 먼저 첫단계에서는 내가 임계 영역에 진입하기를 원한다는 상태(want-in)을 설정하고 내 차례(turn == i)가 올 때까지 while을 돌며 대기한다. 대기하면서 현재 임계 영역에 진입한 프로세스의 차례 상태를 검사하며(if (flag[turn] == idle)) 만약 현재 차례의 프로세스가 임계 영역을 빠져나와 IDLE 상태로 변경되면 자신의 아이디를 차례에 대입한다(turn = i) 하지만 이때 여러 프로세스가 경쟁 상태로 turn에 자신의 아이디를 대입하기 때문에 2단계에 여러 프로세스가 진입하게 될 수 있다.

2단계에서는 내가 임계 영역에 진입했다고 알리고 (flag[i] = in-CS), 현재 나를 제외한 다른 프로세스도 2단계에 접속 했는지 검사한다. 이때 j가 프로세스의 개수만큼 검사를 했지만 나를 제외한 모든 프로세스가 in-CS가 아니면 임계 영역에 진입하게 된다.

이처럼 다익스트라는 운이 나쁘다면 임계영역에 아무것도 없지만 1단계와 2단계를 여러번 수행할 수 있다.

### SW 해결의 문제점

- 속도가 느림
- 구현이 복잡함
- ME primitive 실행 중 preemption 될 수 있음
  - 공유 데이터 수정 중은 interrupt를 억제 함으로서 해결 가능
    - Overhead 발생
- **Busy waiting**
  - Inefficient

