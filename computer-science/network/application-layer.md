# 응용 계층

## 개념과 구조

응용 계층에 존재하는 응용 프로그램은 다음 두 가지 형태로 존재하며 각각의 특징은 다음과 같다.

### Client-server 구조

#### 서버의 특징

* 항상 실행되고 있다.
* 영구적으로 할당된 IP를 가짐
* 확장을 위한 데이터 센터가 존재

#### 클라이언트의 특징

* 서버와 통신
* 클라이언트간의 직접적인 통신을 하지 않음
* 간혈적인 연결 \(연결과 끊김이 반복적이고 규칙적이지 않다.\)
* 대부분 동적 IP를 사용

### Peer-to-peer 구조

* 항상 켜져있는 서버가 존재하지 않음
* 임의의 클라이언트와 직접적인 통신
* Peer는 클라이언트이자 서버의 역할을 한다.
  * 데이터를 수신하고 때로는 제공하는 임무를 가진다.
  * 따라서 Peer가 증가하면 성능적인 확장성이 가능하다.
* Peer는 간혈적인 연결 상태를 가지며, IP 주소가 변경이 가능하다
  * 통신이 항상 원활하고 지속적인 통신이 가능하다는 보장이 없고
  * Peer들의 관리가 힘들다

따라서 인터넷에서 통신하기 위해선 클라이언트 프로세스와 서버 프로세스가 존재해야한다. 그리고 각 프로세스는 message를 다른 프로세스에게\(으로 부터\) 송수신하기 위해선 전송 계층에 전달할 필요가 있고, 응용 계층과 전송 계층의 통로가 `Socket`이라 한다. 때문에 소켓으로 전달되는 메세지는 IP를 통해 인터넷에 퍼져있는 목적지를 특정할 수 있고, 목적지 내부에 프로세스를 특정하는 것이 `포트 번호`이다.

응용 계층의 프로그램은 전송 계층으로부터 전송을 요청하는데 이런 프로그램은 서비스마다 필요로하는 요구사항이 나뉘게 된다.

* 데이터 무결성
  * 파일 전송, 웹등은 데이터의 무결성이 깨지면 서비스의 존재 의미가 사라진다. 때문에 전송 계층으로 부터 모든 데이터가 정확히 들어왔는지가 중요하다
* 응답 시간
  * 인터넷 통화, 게임과 같은 서비스는 전송된 데이터가 일정한 시간 내에 목적지에 도착이 보장되어야 서비스가 유지된다.
* 처리량
  * 멀티미디어 스트리밍같은 경우 단위 시간 내에 일정 프레임이 도착됨이 보장되어야 서비스가 끊김없이 유지된다.
* 보안
  * 앞서 데이터 무결성과 보안이 중요한 서비스

![&#xC11C;&#xBE44;&#xC2A4;&#xBCC4; &#xC694;&#xAD6C;&#xC0AC;&#xD56D;](https://i.imgur.com/v6zFqat.png)

## 프로토콜

### 전송 계층에서 제공하는 서비스의 종류

#### TCP

* 송신을 하는 두 프로세스간의 전송의 신뢰성 보장
* 데이터 전송 흐름 제어 \(송수신간의 데이터 흐름을 제어, 너무 빠른 송신을 하면 수신쪽 버퍼에 가득찰 경우 데이터 손실일 막음\)
* 두 프로세스간의 연결 수립
* 혼잡 제어 \(네트워크 상황에 따라서 송신을 제어\)

#### UDP

* 송신을 하는 두 프로세스간의 전송을 신뢰성을 보장하지 않음

인터넷 전송 프로토콜은 두 개의 서비스를 제공하는데 UDP의 경우 TCP에 비해 많은 부분이 부족하지만 TCP의 통신 프로세스간의 연결 수립의 비용을 줄이고, 프로세스 내에서 수신 데이터 무결성을 검사한다면 TCP와 동일한 작업을 하게 된다. 또 TCP의 경우 네트워크 상황에 따라서 단위 시간 수신량이 보장되어야 하는 경우에도 의도하지 않게 전송 계층에서 수신량이 제한되게 된다.

다음은 응용 계층 프로토콜에서 정의되어야 하는 항목에 대해서 알아보자

* 교환하는 메세지의 종류
  * e.g., request, response
* 메세지의 문법
  * 메세지에 어떤 필드가 있고 각 필드간의 구분을 정의
* 메세지의 해석 방법
  * 필드들이 무엇을 의미하는지
* 송수신간의 규칙

### 웹과 HTTP\(Hypertext transfer protocol\)

HTTP는 Client-Server 구조를 가지며 클라이언트 브라우저를 통해 서버에 접속하고 웹서버는 요청을 받고 응답을 보내주게 된다. 이와 같이 프로토콜을 통해서 통신하게 되면 어떤 디바이스인지, 프로세스에 상관없이 HTTP 프로토콜을 정의에 따라서 통신이 가능하다.

HTTP 프로토콜은 데이터 무결성이 중요한 TCP를 사용해 통신하며 서버는 80포트를 사용하게 된다. 여기서 중요한 점은 HTTP는 동일한 사용자의 요청이라도 모두 각각의 연관성이 없는 개별적인 요청으로 처리하는 stateless 방식으로 통신한다. 만약 HTTP를 stateful하게 만들려면 많은 개발 비용과 자원이 필요하기 때문에 많은 프로토콜은 stateless하게 동작한다.

**Non-persistent HTTP**

하나의 요청에 대해 완료 시점에서 통신을 닫음

![](https://i.imgur.com/ZXFbzH5.png) 

![](https://i.imgur.com/hjEUE21.png)

- 1) 클라이언트는 목적지 주소(IP, URL)와 포트(HTTP의 경우 80포트)로 요청을 보냄
- 2) 서버는 클라이언트가 보낸 요청에 대해 연결을 수립하고 클라이언트에게 알림 (RTT)
- 3) 연결 신호가 오면 클라이언트는 서버에게 본격적으로 `요청 메세지`를 보냄
- 4) 서버는 요청에 대한 `응답 메세지`를 보내고 TCP 통신을 **끊음** (RTT)
- 5) 클라이언트는 응답받은 메세지를 분석하고, 화면에 표시
- 6) 분석 내용에 추가적으로 서버에 요청이 필요한 데이터의 경우 다시 1번의 과정을 수행

따라서 한번의 HTTP 통신에서 응답 시간은 `2RTT + file transmission time`이라고 할 수 있다. base HTML을 수신한 후 추가적인 요청은 브라우저에서 병렬적으로 요청하여 처리하지만 앞서 TCP의 연결에 대해 비용 소비는 해결할 수 없고, 운영체제는 병렬적인 TCP 소켓을 할당하고 그에 따른 버퍼(TCP 소켓별 혼잡 제어 및 흐름 제어를 위한 버퍼)를 처리하기 때문에 부담이 된다.

**Persistent HTTP**

앞서 초기 HTTP 통신의 문제점을 해결하고자 현대의 HTTP는 통신된 소켓을 닫지 않고 유지한다. 따라서 추가적인 요청은 처음 통신한 소켓을 사용해 추가적인 통신은 1RTT만에 처리할 수 있다. 추가적으로 Persistent HTTP와 연관된 HTTP 요청 헤더는 `Connection: keep-alive`이다.

#### HTTP 메세지

![](https://i.imgur.com/LYDBqD8.png)

HTTP 메세지는 요청과 응답 두 가지 형태를 가진다. 각 형태는 ASCII로 작성된다. 여기서 요청에 필요한 값을 포함해야 하는데, 마지막 Body 영역엔 POST 메서드로 요청한 데이터들이 위치하고 GET 메서드의 경우 URL 필드에 `?` 구분자를 기준으로 내용을 포함하게 된다.

##### 요청/응답별 메세지

###### 요청 메세지

![](https://i.imgur.com/BAcEyEp.png)

- 요청 메서드
  - HTTP/1.0
    - GET
    - POST
    - HEAD
      - 서버에게 응답은 주지만 컨텐츠 내용을 전송하지 않기를 요청한다. 테스트 목적으로 사용

  - HTTP/1.1
    - GET, POST, HEAD
    - PUT
    - DELETE

###### 응답 메세지

![](https://i.imgur.com/niERYAd.png)

- 응답 상태 코드
  - 200 ok
  - 301 Moved Permanently
  - 400 Bad Request
  - 404 Not Found
  - 505 HTTP Version Not Supported

