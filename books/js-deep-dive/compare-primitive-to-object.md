# 원시 값과 객체의 비교

6장에서 살펴보았듯이 자바스크립트에선 크게 윈시 타입, 객체 타입으로 구분할 수 있다. 두 타입의 구분은 다음과 같은 측면에서 구분할 수 있다.

- 원시 값은 변경 불가능한 값이고, 객체 타입의 값은 변경 가능한 값이다.
- 원시 값은 변수에 할당하면 변수에는 실제 값이 저장된다. 객체는 변수에 할당하면 변수에 참조 값이 저장된다.
- 원시 값은 다른 변수에 할당하면 원시 값이 복사되어 전달된다(값에 의한 전달). 객체는 참조 값이 복사되어 전달된다(참조에 의한 전달).

## 원시 값

원시 값은 변경이 불가능하기 때문에 읽기 전용으로써 변경이 불가능하다. 여기서 오해할 수 있는 부분은 원시 값이 할당된 변수가 변경이 불가능한 상수를 의마하는게 아닌, 원시 값 그 자체에 대한 설명이다.

따라서 변수에 원시 값을 할당하는 경우 불변성이라는 특성 때문에 기존 메모리에 저장하는게 아니라, 새로운 메모리를 생성한다. 이 특성은 원시 값을 가지는 변수를 다른 변수에 대입하는 경우도 같은 동작을 수행하는데 아래 코드에서 foo와 bar는 독립된 메모리를 가진다.

```javascript
var foo = 3;
var bar = foo;
console.log(foo === bar);
```

 결국 두 변수의 원시 값은 *별개의 공간에 존재하는 별개의 값*으로 서로는 변경에 간섭할 수 없다.

### 문자열과 불변성

앞서 불변성에 따라서 원시 값이 재할당시 메모리를 다시 만든다는 건 알 수 있다. 따라서 메모리를 새로 만들 크기를 알아야 하지만, 문자열의 경우 문자열의 길이에 따라 확보해야 할 메모리 공간이 달라진다.

C언어의 경우 문자 타입인 char은 존재하지만 문자열에 대한 문자열 타입은 제공하지 않는다. 하지만 자바스크립트의 경우 문자열을 원시 타입으로 제공하며 다른 원시 값과 같이 불변성 특성을 가진다.

```javascript
var str = 'string';
str = 'hello'; // new memory

str[0] = 'H'; // immutability
console.log(str); // hello
```

문자열은 유사 배열 객체이면서 이터러블이므로 배열처럼 접근할 수 있다.

## 객체

객체는 프로퍼티의 개수가 정해져 있지 않고, 또 동적으로 추가와 삭제가 가능하기 때문에 확보할 메모리 크기를 특정할 수 없다. 또 브라우저 제조사마다 객체의 관리 방법이 다르고 복잡하다.

C++의 경우 객체는 미리 만들어진 클래스를 기반으로 객체를 생성한다. 하지만 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 내부 정보도 동적으로 변경이 가능하기 때문에 객체지향 프로그래밍 언어의 객체보다 프로퍼티 접근에 많은 비용이 든다.

 V8은 비싼 프로퍼티 접근을 해결하기 위해 동적 탐색 대신 히든 클래스 방식을 사용하는데 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

### 변경 가능한 값

객체는 변경 가능한 값이다. 객체가 할당된 변수는 객체가 할당된 메모리를 기억하며 참조 값으로 접근할 수 있다. 참조 값은 객체가 존재하는 메모리 공간의 주소 그 자체를 의미한다.

원시 값은 값을 변경하는 경우 메모리를 재할당하여 전혀 다른 메모리 공간을 가지게 되는 반면에 객체를 담고 있는 변수는 참조값을 가지고 있기 때문에 객체의 내부 값이 변경된다고 하더라도 변수가 가지고 있는 메모리 주소가 변경되지 않는다. 만약 객체가 원시 값과 같이 불변성을 가지며 변경이 있을 시 새로운 메모리를 할당하게 된다면 메모리의 효율적인 사용성과 객체의 복사하는 비용 때문에 성능을 크게 떨어지기 때문에 그런 점을 감안한 설계라고 할 수 있다.

하지만 이런 특성 때문에 단점 또한 존재하는데, 객체를 담고 있는 변수는 참조 값을 가지기 때문에 여러 변수가 같은 참조 위치를 가지고 있다면 변경에 대한 추적과 동작 예측, 디버깅을 어렵게 만들 수 있다.

### 얕은 복사 깊은 복사

객체의 참조 값을 저장하는 특성은 복사에서도 문제가 생길 수 있다.

```javascript
const o = {x: {y: 1}};
const c1 = {...o};
```

스프레드 연산을 통해서 o를 c1으로 복사를 하게 되면 객체는 새로운 메모리 공간에 같은 할당되어 복사가 된 '것' 처럼 볼 수 있다. 하지만 내부 원시 값들은 여전히 공유된 상태기 때문에 진정한 복사가 아닌 얕은 복사다. 깊은 복사를 위해선 구현의 부담을 줄이기 위해서 외부 라이브러리를 이용할 필요가 있다.

자바스크립트에선 원시 값과 객체 값은 자신이 가진 메모리 주소를 대입한다. 그게 원시 값인지, 객체인지에 따라 접근 방식이 달라질 뿐이다.

### 비교

```javascript
var person1 = {name:'Lee'};
var person2 = {name:'Lee'};

console.log(person1 === person2);
console.log(person1.name === person2.name);
```

일치 비교 연산자는 비교 대상이 가진 값이 참조 값인지 원시 값인지에 따라서 다르게 된다. 4행의 비교는 참조 값을 비교하기 때문에 두 객체는 같은 모양이지만 다른 메모리에 위치하기 때문에 서로 다른 참조 값을 가지기 때문에 `false`이다. 5행의 일치 비교 연산자는 원시 값을 비교하게 된다. 따라서 두 원시 값 'Lee'는 동일하기 때문에 `true`이다.
