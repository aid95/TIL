# 영속성 관리

> 김영한 저자의 "자바 ORM 표준 JPA 프로그래밍"을 학습하며 정리한 글입니다. 내용의 중요한 부분을 생략하였기에 자세한 내용을 원하신다면 도서를 구매하는 걸 추천해 드립니다.

![&#xC790;&#xBC14; ORM &#xD45C;&#xC900; JPA &#xD504;&#xB85C;&#xADF8;&#xB798;&#xBC0D;](https://i.imgur.com/kz3qpQs.jpg)

## 자바 ORM 표준 JPA 프로그래밍

### 영속성 컨텍스트

영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻을 가진다. 엔티티 매니저로 엔티티를 저장, 조회하면 엔티티 매니저는 영속성 컨텍스트에 보관하여 관리하게 된다.

```text
em.persist(member);
```

앞서 설명되어진 위 코드는 엔티티 매니저를 사용해 회원 엔티티를 영속성 컨텍스트에 저장한다.

### 엔티티의 생명주기 \(P.93\)

* 비영속
  * 영속성 컨텍스트와 전혀 관계가 없는 상태
* 영속
  * 영속성 컨텍스트에 저장된 상태, 따라서 영속성 컨텍스트에 의해 관리된다.
* 준영속
  * 영속성 컨텍스트에 저장되었다가 분리된 상태
* 삭제
  * 삭제된 상태

### 영속성 컨텍스트의 특징 \(P.96\)

* 영속성 컨텍스트와 식별자 값
  * 영속 상태는 식별할 수 있는 값이 반드시 있어야 한다.
* 영속성 컨텍스트와 데이터베이스 저장
  * 영속성 컨텍스트가 데이터베이스에 반영되는 플러시는 트랜잭션을 커밋하는 순간 발생한다.
* 영속성 컨텍스트의 장점
  * 1차 캐시
    * 영속 상태의 엔티티를 저장하고 있는 내부 캐시 저장소를 이용해 식별 가능한 엔티티에 대한 조회/수정/삭제등을 할 수 있다.
  * 동일성 보장
    * 앞서 설명한 캐시를 이용해 동일한 엔티티에 대한 여러번의 조회시 동등성을 가진 객체가 아니라, 동일한 객체를 가져올 수 있다. 따라서 성능과 동일성을 보장한다.
  * 트랜잭션을 지원하는 쓰기 지연
    * 영속된 엔티티에 대해 그때그때 데이터베이스에 저장하지 않고 쿼리 저장소에 쌓아둔 뒤 트랜잭션이 커밋된 순간 일괄적으로 데이터베이스와 동기화가 이뤄진다.
  * 변경 감지
    * 영속성 컨텍스트는 엔티티가 보관될 때 초기 상태를 저장한다. 이를 스냅샷이라고 하면 플러시 시점에 현재 엔티티와 스냅샷을 비교해 수정이 이뤄진다. 따라서 영속 상태의 엔티티에만 적용된다.
    * JPA의 수정은 모든 필드에 대해 이뤄진다. 따라서 데이터베이스에 전송되는 데이터량이 증가하지만 업데이트 쿼리의 일관성을 유지할 수 있고, 따라서 데이터베이스가 동일한 쿼리에 대한 최적화 이점을 누릴 수 있다.
      * **@org.hibernate.annotations.DynamicUpdate** 를 이용해 대상 필드만 적용되는 동적인 업데이트 쿼리도 지원한다.
  * 지연 로딩

### 플러시 \(P.108\)

플러시는 영속성 컨텍스트의 변경 내용, 즉 변경 감지된 엔티티와 쓰기 지연 SQL 저장소의 쿼리를 전송해 데이터베이스에 반영한다. 영속성 컨텍스트를 플러시하는 방법은 3가지다.

* 직접 호출
* 트랜잭션 커밋 시 자동 호출
* JPQL 쿼리 실행

만약 엔티티 매니저에 플러시 모드를 직접 지정하려면 `javax.persistence.FlushModeType`을 직접 설정할 수 있다.

* FlushModeType.AUTO \(default\)
* FlushModeType.COMMIT

COMMIT 모드는 성능 최적화를 위해 사용할 수 있는데 자세한 내용은 10장에서 설명된다.

여기서 Flush라는 이름으로 인해 Flush되었다고 영속성 컨텍스트에 보관된 엔티티가 지워진다고 생각하면 안되고 데이터베이스와 동기화를 하는 것이 Flush라는 것을 기억하자.

### 준영속 \(P.110\)

준영속 상태는 영속 상태의 엔티티가 영속성 컨텍스트에서 제외된 상태를 의미한다. 따라서 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.

#### em.detach

```java
public void detach(Object entity);
```

detach를 통해 특정 영속 상태의 엔티티를 준영속 상태 엔티티로 바꿀수 있다. 따라서 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티의 관리 정보가 모두 제거된다. 당연하게도 INSERT SQL도 제거되었기 때문에 저장도 할 수 없다.

#### em.clear

clear는 영속성 컨텍스트 내부의 모든 엔티티를 준영속 상태로 바꿔버린다. 따라서 영속성 컨텍스트를 제거하고 새롭게 만드는 것과 같다.

#### em.close

close는 영속성 컨텍스트를 닫음으로 영속성 컨텍스트에 포함되어있던 모든 엔티티가 사라진다.

준영속 상태로 변경된 엔티티는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩등 영속성 컨텍스트에 제공되는 어떤 기능도 동작하지 않기 때문에 비영속 상태에 가까워진다. 하지만 비영속 상태의 경우 식별자 값이 없을 수 있지만 준영속 상태인 엔티티는 한번 영속된 상태였기 때문에 반드시 식별자 값을 가진다는 차이점이 있다.

여기까지 영속 상태였던 엔티티를 준영속으로 변경하는 방법이고 이제는 준영속 상태를 영속 상태로 변경하는 방법을 알아보자. 먼저 준영속 상태였던 엔티티를 영속으로 바꾸기 위해선 merge\(\)를 사용하여 변경할 수 있다. 주의할 점은 _준영속 상태 엔티티의 상태가 변경된 것이 아니라 새로운 영속 상태의 엔티티를 만든다는 것_이다.

```java
Member mergeMember = em2.merge(member);
```

병합\(merge\)는 준영속 상태 엔티티뿐만 아니라 비영속 엔티티도 영속 상태로 만들 수 있다. 따라서 병합은 _save or update_ 기능을 수행한다.

